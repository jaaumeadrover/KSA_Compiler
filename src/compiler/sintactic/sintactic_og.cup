
/**
 Per compilar aquest fitxer s'ha d'haver instal·lat JavaCup

  java -jar java-cup-11b.jar sintactic.cup

alternativament

  java -classpath path_fins_java-cup-11b.jar java_cup.Main sintactic.cup

 **/

/**
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica
 * Itinerari: Intel·ligència Artificial i Computació
 *
 * Professor: Pere Palmer
 */
package compiler.sintactic;



import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import compiler.Symbols.TaulaSimbols.*;
import compiler.ArbreSintactic.*;
import compiler.GeneracioCodiIntermedi.*;
import compiler.Semantic.Semantic;

import java_cup.runtime.*;


import java.io.PrintStream;
import java.util.HashMap;

class Parser;

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
**/
parser code {:
    private TaulaSimbols ts=new TaulaSimbols();
    private Scanner scanner;
    private Semantic comprovaTipus=new Semantic(ts);
    private ArbreSintactic arbre=new ArbreSintactic();
    private codiTresAdreces codi=arbre.generarCodiTresAdreces();

    public Parser(Scanner scanner){
        this.scanner = scanner;
    }

    private HashMap<String, Double>tsymbols = new HashMap<>();

    public Double getSymbolValue(String id) {
         return tsymbols.get(id);
    }

    public void addSymbol(String id, Double value) {
        if (tsymbols.get(id) == null) {
            tsymbols.put(id, value);
        } else {
            tsymbols.replace(id, value);
        }
    }

    public void printVars(PrintStream out) {
        if (tsymbols.size() == 0) {
            out.println("No hi ha variables declarades");
        } else {
            String fmt = "%-8s: %f";
            tsymbols.forEach((k,v) -> out.println(String.format(fmt,k,v)));
        }
    }

    /**
     * Variable utilitzada per emmagatzemar el darrer valor calculat.
     * Val 0 inicialment
     **/
    private double ans = 0;

:}

/**
 ** També aquí es poden afegir accions a realitzar quan es requereix un token.
scan with {:     next_token(); :}
**/


//TERMINALS

//identificadores
terminal id,bool,string;
//enteros
terminal integer;
//operadors
terminal bg, sm, bg_eq, sm_eq, eq, neg;
//operaciones
terminal add, sub, mul, div, mod;
//caracteres suplementarios
terminal asig, smcol, twodots, com, brop, brcl, lop, lclose, lparen, rparen;
//palabras reservadas
terminal r_if, r_else, r_switch, r_case, r_default, r_break, r_function, r_procedure, r_return, r_while, r_for, r_const,
         r_and, r_or, r_not, r_int, r_bool, r_main, r_string,r_input,r_print;

non terminal M;



non terminal  SymbolProgram   program;
non terminal  SymbolDeclList  declList;
non terminal  SymbolDecl   decl;
non terminal  SymbolVarDecl  varDecl;
non terminal  SymbolVarInit  varInit;
non terminal  SymbolFuncDecl   funcDecl;
non terminal  SymbolFuncCap   funcCap;
non terminal  SymbolProcDecl   procDecl;
non terminal  SymbolArgType   argType;
non terminal  SymbolType   type;
non terminal  SymbolStatementList   statementList;
non terminal  SymbolStatement   statement;
non terminal  SymbolWhileStatement   whileStatement;
non terminal  SymbolForIteration   forIteration;
non terminal  SymbolForInit   forInit;
non terminal  SymbolForPostExpression   forPostExpression;
non terminal  SymbolIfStatement   ifStatement;
non terminal  SymbolElseStatement   elseStatement;
non terminal  SymbolExpressioSimple  exprSimple;
non terminal  SymbolSubProgramCall   subProgramCall;
non terminal  SymbolSubProgramContCall   subProgramContCall;
non terminal  SymbolArray      array;
non terminal  SymbolArrayInit  arrayInit;
non terminal  SymbolContCap ContCap;
non terminal  SymbolReturn return;
non terminal  SymbolOp op;
non terminal  SymbolOperacio operacio;
non terminal  SymbolValor valor;
non terminal  SymbolBoolOp boolOp;
non terminal  SymbolAritOp aritOp;
non terminal  SymbolRealOp realOp;
non terminal  SymbolSwitchCase SwitchCase;
non terminal  SymbolLCases LCases;
non terminal  SymbolCase Case;
non terminal  SymbolDefault Default;
non terminal  SymbolInputStatement inputStatement;
non terminal  SymbolPrintStatement printStatement;
non terminal  SymbolStringValue stringValue;
non terminal  SymbolLiteral literal;

precedence right asig;
precedence left  add, sub;
precedence left  mul, div, mod;


start with program;

program ::= declList:declist r_main lparen rparen brop statementList:states brcl {:RESULT = new SymbolProgram(declist,states);:}
    ;

//DECLARACIONS
declList ::= declList decl {:RESULT=new SymbolDeclList();:} //NO FA FALTA
    |                      {:RESULT=new SymbolDeclList();:}
    ;
decl ::= varDecl smcol    {:RESULT = new SymbolDecl(codi);:}  //NO FA FALTA
    | funcDecl            {:RESULT = new SymbolDecl(codi);:}
    | procDecl            {:RESULT = new SymbolDecl(codi);:}
    ;
//DECLARACIÓ VARIABLES
varDecl ::=  r_const type:t id:iden varInit:varinit     {:RESULT=new SymbolVarDecl(true, t.getTipusSub(), iden.toString(),varinit,codi);
                                                        ts.afegeixSimbol(iden.toString(), t.getTipusSub(), Tipus.CONST, 0);:}//declaració de una constant
    |type:t id:iden varInit:varinit                    {:RESULT=new SymbolVarDecl(false,t.getTipusSub(),iden.toString(),varinit,codi);
                                                        if(varinit.isIsarray()){
                                                                ts.afegeixSimbol(iden.toString(),t.getTipusSub(), Tipus.ARRAY,0);
                                                            }
                                                            else{
                                                                ts.afegeixSimbol(iden.toString(),t.getTipusSub(), Tipus.VAR,0);
                                                            }
                                                       :}//declaració d'una variable
    |varDecl:vard com id:iden varInit:varinit          {:RESULT=new SymbolVarDecl(vard.esConst(), vard.getTipusSub(), iden.toString(),varinit,codi);
                                                        if(vard.esConst()){
                                                            ts.afegeixSimbol(iden.toString(),vard.getTipusSub(), Tipus.CONST,0);
                                                        }
                                                        else{
                                                            ts.afegeixSimbol(iden.toString(),vard.getTipusSub(), Tipus.VAR,0);
                                                        }
                                                        :}
    ;

varInit ::= asig exprSimple:expr             {:RESULT =new SymbolVarInit(expr,codi);:}     //asigació d'un valor a una variable
    |asig arrayInit:arrayInit                {:RESULT =new SymbolVarInit(arrayInit,codi);:}
    |                                        {:RESULT = new SymbolVarInit(false);:}
    //|asig subProgramCall                 {:RESULT =new SymbolVarInit();:}
    ;
//ARRAYS!
arrayInit ::=type:t lop exprSimple:expr lclose {:RESULT =new  SymbolArrayInit(t.getTipusSub(),expr,codi);:}
;//inicialització d'un array: 'nom' [arrayEllist]

type ::= r_int                 {:RESULT=new SymbolType(TipusSub.INT,codi);:}
    |r_bool                    {:RESULT=new SymbolType(TipusSub.BOOLEAN,codi);:}
    |r_string                  {:RESULT=new SymbolType(TipusSub.STRING,codi);:}
    ;


//FUNCIONS
return   ::=r_return exprSimple:expr smcol  {:RESULT = new SymbolReturn(expr,codi);:}
;
funcDecl ::= r_function type:t  id:iden funcCap:funcCap M brop statementList:stats return:rtn brcl {:
                                                                                System.out.println("SIMBOL S: "+ts.getMida());

                                                                                Simbol s=ts.consultaFunc(iden.toString());
                                                                                System.out.println("SIMBOL S: "+s);
                                                                                if(s == null){
                                                                                    if(comprovaTipus.gestFunc(t.getTipusSub,rtn)){
                                                                                        RESULT=new SymbolFuncDecl(t.getTipusSub(), iden.toString(), stats, rtn,funcCap,codi);
                                                                                        ts.afegeixSimbol(iden.toString(), t.getTipusSub(), Tipus.FUNC, 0);
                                                                                    }

                                                                                }else{
                                                                                    System.out.println("FUNCIÓ JA CREADA ANTERIORMENT!");
                                                                                    RESULT=new SymbolFuncDecl();
                                                                                }
                                                                                :};
funcCap ::= ContCap:contcap rparen          {:RESULT=new SymbolFuncCap(contcap,codi);:}               //declaració de parentesis per als arguments
    | lparen rparen                         {:RESULT=new SymbolFuncCap(codi);:}
    ;

procDecl ::= r_procedure id:iden funcCap:funcCap M brop statementList:stats brcl{:RESULT =new SymbolProcDecl(iden.toString(), stats,funcCap,codi);
                                                                                ts.afegeixSimbol(iden.toString(), TipusSub.NULL, Tipus.FUNC, 0);:}; //declaració d'un procediment: proc 'nom' parametres {...}

ContCap ::= lparen argType:arg type:t id:iden              {:RESULT = new SymbolContCap(arg,t.getTipusSub(), iden.toString(),codi);:}//tancam parentesis i definim els paràmetres
    | ContCap:contcap com argType:arg type:t id:iden       {:RESULT = new SymbolContCap(contcap,arg,t.getTipusSub(), iden.toString(),codi);:}
    ;

argType ::= r_const {:RESULT = new SymbolArgType(true,codi);:}   //tipus d'argument (constant o no)
    |               {:RESULT = new SymbolArgType(false,codi);:}
    ;
//INSTRUCCIONS
statementList ::= statement:stat statementList:stats {:RESULT= new SymbolStatementList(stat,stats,codi);:}      //declaració d'una llista
    |                                                {:RESULT=new SymbolStatementList(codi);:}
    ;

statement ::= varDecl:vard smcol         {:RESULT=new SymbolStatement(vard,codi);:}
    |exprSimple:expr smcol               {:RESULT=new SymbolStatement(expr,codi);:}
    |forIteration:f                      {:RESULT=new SymbolStatement(f,codi);:}
    |whileStatement:w                    {:RESULT=new SymbolStatement(w,codi);:}
    |inputStatement:input smcol          {:RESULT=new SymbolStatement(input,codi);:}
    |printStatement:print smcol          {:RESULT=new SymbolStatement(print,codi);:}
    |ifStatement:i                       {:RESULT=new SymbolStatement(i,codi);:}
    |SwitchCase:s                        {:RESULT=new SymbolStatement(s,codi);:}
    |r_break smcol                       {:RESULT=new SymbolStatement(codi);:}
    ;

inputStatement ::= r_input lparen rparen {:RESULT = new SymbolInputStatement(codi);:};

printStatement ::= r_print lparen stringValue rparen {:RESULT = new SymbolPrintStatement(codi;:};

stringValue    ::= literal
                   | stringValue add literal {:RESULT = new SymbolStringValue(codi);:};

literal ::=          string {:RESULT = new SymbolLiteral(codi);:}
                    | valor {:RESULT = new SymbolLiteral(codi);:};


//EXPRESSIONS
exprSimple ::=lparen exprSimple:expr rparen operacio:oper {:RESULT=new SymbolExpressioSimple(expr,oper,codi);:}
    |valor:val operacio:oper                              {:RESULT=new SymbolExpressioSimple(val, oper,codi);:}
    ;

valor::= id:iden                         {:
                                            Simbol s=ts.consulta(iden.toString());
                                            if(s!=null){
                                                RESULT=new SymbolValor(iden.toString(),s.getTipusSub(),codi);
                                            }else{
                                                //System.out.println("Aquesta variable no existeix");
                                                //he afegit null perque sinos el confonia amb el constructor de integer!
                                                //THROWS EXCEPTION??????
                                                RESULT=new SymbolValor(iden.toString(),TipusSub.INT,codi);
                                            }
                                         :}
    |array:arr                                      {:RESULT=new SymbolValor(arr,codi);:}
    |integer:integer                                {:RESULT=new SymbolValor(integer,codi);:}
    |bool                                           {:RESULT=new SymbolValor(true,codi);:}
    |r_not bool                                     {:RESULT=new SymbolValor(false,codi);:}
    |r_not  lparen exprSimple:exprSimple rparen     {:RESULT=new SymbolValor(exprSimple,codi);:}
    |subProgramCall:subprogram                      {:RESULT=new SymbolValor(subprogram,codi);:}
    ;

array::=id:iden lop exprSimple:expr lclose {:RESULT=new SymbolArray(iden.toString(),expr,codi);:}
;

operacio::=op:op exprSimple:expr   {:RESULT = new SymbolOperacio(op,expr,codi);:}
| varInit:vard                     {:RESULT = new SymbolOperacio(vard,codi);:}
 ;

//OPERADORS
op::= boolOp:bool   {:RESULT = new SymbolOp(bool,codi);:}
|aritOp:arit        {:RESULT = new SymbolOp(arit,codi);:}
|realOp:realOp      {:RESULT = new SymbolOp(realOp,codi);:}
;

boolOp::= r_and {:RESULT = new SymbolBoolOp(operacions.AND,codi);:}
|r_or           {:RESULT = new SymbolBoolOp(operacions.OR,codi);:}
;

aritOp ::= add {:RESULT = new SymbolAritOp(operacions.ADD,codi);:}
|sub           {:RESULT = new SymbolAritOp(operacions.SUB,codi);:}
|mul           {:RESULT = new SymbolAritOp(operacions.MUL,codi);:}
|div           {:RESULT = new SymbolAritOp(operacions.DIV,codi);:}
|mod           {:RESULT = new SymbolAritOp(operacions.MOD,codi);:}
;

realOp::= neg {:RESULT = new SymbolRealOp(operacions.NEG,codi);:}
|eq           {:RESULT = new SymbolRealOp(operacions.EQ,codi);:}
|bg           {:RESULT = new SymbolRealOp(operacions.BG,codi);:}
|sm           {:RESULT = new SymbolRealOp(operacions.SM,codi);:}
|bg_eq        {:RESULT = new SymbolRealOp(operacions.BGEQ,codi);:}
|sm_eq        {:RESULT = new SymbolRealOp(operacions.SMEQ,codi);:}
;


subProgramCall ::= id:iden lparen rparen            {:RESULT = new SymbolSubProgramCall(iden.toString(),codi);:}
|subProgramContCall:subprogcontcall rparen          {:RESULT = new SymbolSubProgramCall(subprogcontcall,codi);:}
;

subProgramContCall ::= id:iden lparen exprSimple:expr            {:RESULT = new SymbolSubProgramContCall(iden.toString(), expr,codi);:}
    |subProgramContCall:subprogcontcall com exprSimple:expr      {:RESULT = new SymbolSubProgramContCall(subprogcontcall, expr,codi);:}
    ;

SwitchCase ::= r_switch lparen exprSimple:expr rparen brop LCases:lcases Default brcl {:RESULT = new SymbolSwitchCase(expr,lcases,codi);:};

LCases ::= Case:c LCases:lcases         {:RESULT = new SymbolLCases(c,lcases,codi);:}
    |                                   {:RESULT = new SymbolLCases();:};

Case ::= r_case exprSimple:expr twodots statementList:state {:RESULT = new SymbolCase(expr,state,codi);:};

Default ::= r_default twodots statementList:state           {:RESULT = new SymbolDefault(state,codi);:}
    |                                                       {:RESULT = new SymbolDefault();:}
    ;

forIteration ::= r_for lparen forInit:forinit
smcol exprSimple:expr smcol forPostExpression:forpost
rparen brop statementList:state brcl                    {:if(comprovaTipus.gestExpr(expr,TipusSub.BOOLEAN)){
                                                               RESULT = new SymbolForIteration(forinit,expr,forpost,state,codi);
                                                         }else{
                                                              RESULT = new SymbolIfStatement();
                                                              System.out.print("   Aixó NO ES CORRECTE AL FOR");
                                                         }:}
    ;

forInit ::= varDecl:vardecl                         {:RESULT = new SymbolForInit(vardecl,codi);:}//inicialització de l'iterador
    |                                               {:RESULT = new SymbolForInit();:};

forPostExpression ::= exprSimple:expr               {:RESULT = new SymbolForPostExpression(expr,codi);:}//declaració de la postExpressio
    |                                               {:RESULT = new SymbolForPostExpression();:}
    ;

whileStatement ::= r_while lparen exprSimple:expr
rparen brop statementList:state brcl                {:if(comprovaTipus.gestExpr(expr,TipusSub.BOOLEAN)){
                                                        RESULT = new SymbolWhileStatement(expr,state,codi);
                                                     }else{
                                                          RESULT = new SymbolWhileStatement();
                                                           System.out.print("   Aixó NO ES CORRECTE AL WHILE");
                                                    }
                                                    :};


ifStatement ::= r_if lparen exprSimple:expr
rparen brop statementList:stateif brcl   {:if(comprovaTipus.gestExpr(expr,TipusSub.BOOLEAN)){
                                             RESULT = new SymbolIfStatement(expr,state,codi);
                                           }else{
                                              RESULT = new SymbolIfStatement();
                                            System.out.print("   Aixó NO ES CORRECTE AL WHILE");
                                           }:}
| r_if lparen exprSimple:expr rparen brop
statementList:statel brcl r_else  brop statementList:stater brcl {:if(comprovaTipus.gestExpr(expr,TipusSub.BOOLEAN)){
                                                                      RESULT = new SymbolIfStatement(expr,state,codi);
                                                                  }else{
                                                                       RESULT = new SymbolIfStatement();
                                                                      System.out.print("   Aixó NO ES CORRECTE AL IF");
                                                                 }:};


//elseStatement ::= brop statementList:state brcl
//    r_else brop statementList:state  {:RESULT = new SymbolElseStatement(state);:}
  //  | brop statementList:state                     {:RESULT = new SymbolElseStatement(state);:}
//    ;



M ::= {:ts.afegeixNivell();:};
