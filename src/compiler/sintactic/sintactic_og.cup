
/**
 Per compilar aquest fitxer s'ha d'haver instal·lat JavaCup

  java -jar java-cup-11b.jar sintactic.cup

alternativament

  java -classpath path_fins_java-cup-11b.jar java_cup.Main sintactic.cup

 **/

/**
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica
 * Itinerari: Intel·ligència Artificial i Computació
 *
 * Professor: Pere Palmer
 */
package compiler.sintactic;



import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

import java_cup.runtime.*;

import compiler.Symbols.*;

import java.io.PrintStream;
import java.util.HashMap;

class Parser;

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
**/
parser code {:

    private Scanner scanner;

    public Parser(Scanner scanner){
        this.scanner = scanner;
    }

    private HashMap<String, Double>tsymbols = new HashMap<>();

    public Double getSymbolValue(String id) {
         return tsymbols.get(id);
    }

    public void addSymbol(String id, Double value) {
        if (tsymbols.get(id) == null) {
            tsymbols.put(id, value);
        } else {
            tsymbols.replace(id, value);
        }
    }

    public void printVars(PrintStream out) {
        if (tsymbols.size() == 0) {
            out.println("No hi ha variables declarades");
        } else {
            String fmt = "%-8s: %f";
            tsymbols.forEach((k,v) -> out.println(String.format(fmt,k,v)));
        }
    }

    /**
     * Variable utilitzada per emmagatzemar el darrer valor calculat.
     * Val 0 inicialment
     **/
    private double ans = 0;

:}

/**
 ** També aquí es poden afegir accions a realitzar quan es requereix un token.
scan with {:     next_token(); :}
**/


//TERMINALS

//identificadores
terminal id,bool,string;
//enteros
terminal integer;
//operadors
terminal bg, sm, bg_eq, sm_eq, eq, neg;
//operaciones
terminal add, sub, mul, div, mod;
//caracteres suplementarios
terminal asig, smcol, twodots, com, brop, brcl, lop, lclose, lparen, rparen;
//palabras reservadas
terminal r_if, r_else, r_switch, r_case, r_default, r_break, r_function, r_procedure, r_return, r_while, r_for, r_const,
         r_and, r_or, r_not, r_int, r_bool, r_main, r_string,r_input,r_print;

non terminal  SymbolProgram   program;
non terminal  SymbolDeclList  declList;
non terminal  SymbolDecl   decl;
non terminal  SymbolVarDecl  varDecl;
non terminal  SymbolVarInit  varInit;
non terminal  SymbolFuncDecl   funcDecl;
non terminal  SymbolFuncCap   funcCap;
non terminal  SymbolProcDecl   procDecl;
non terminal  SymbolProcCap   procCap;
non terminal  SymbolArgType   argType;
non terminal  SymbolType   type;
non terminal  SymbolStatementList   statementList;
non terminal  SymbolStatement   statement;
non terminal  SymbolWhileStatement   whileStatement;
non terminal  SymbolForStatement   forIteration;
non terminal  SymbolForInit   forInit;
non terminal  SymbolForPostExpression   forPostExpression;
non terminal  SymbolIfStatement   ifStatement;
non terminal  SymbolElseIfStatement   elseIfStatement;
non terminal  SymbolElseStatement   elseStatement;
non terminal  SymbolExpressioSimple  exprSimple;
non terminal  SymbolSubProgramCall   subProgramCall;
non terminal  SymbolSubProgramContCall   subProgramContCall;
non terminal  SymbolArray      array;
non terminal  SymbolArrayInit  arrayInit;
non terminal  SymbolContCap ContCap;
non terminal  SymbolReturn return;
non terminal SymbolOperador op;
non terminal SymbolOper operacio;
non terminal SymbolValor valor;
non terminal SymbolBoolOp boolOp;
non terminal SymbolAritOp aritOp;
non terminal SymbolRealOp realOp;
non terminal SymbolSwitchCase SwitchCase;
non terminal SymbolLCases LCases;
non terminal SymbolCase Case;
non terminal SymbolDefault Default;
non terminal SymbolInputStatement inputStatement;
non terminal SymbolPrintStatement printStatement;
non terminal SymbolStringValue stringValue;
non terminal SymbolLiteral literal;

precedence right asig;
precedence left  add, sub;
precedence left  mul, div, mod;


start with program;

program ::= declList r_main lparen rparen brop statementList brcl {:RESULT = new SymbolProgram();:} //producció inicial
    ;

//DECLARACIONS
declList ::= declList decl {:RESULT=new SymbolDeclList();:} //Llista declaracions
    |                      {:RESULT=new SymbolDeclList();:}
    ;
decl ::= varDecl smcol    {:RESULT = new SymbolDecl();:}  //declaració de variables,funcions o procediments
    | funcDecl            {:RESULT = new SymbolDecl();:}
    | procDecl            {:RESULT = new SymbolDecl();:}
    ;
//DECLARACIÓ VARIABLES
varDecl ::=r_const type id varInit      {:RESULT=new SymbolVarDecl();:}//declaració de una constant
    |type id varInit                    {:RESULT=new SymbolVarDecl();:}//declaració d'una variable
    |varDecl com id varInit             {:RESULT=new SymbolVarDecl();:}
    ;

varInit ::= asig exprSimple              {:RESULT =new SymbolVarInit();:}     //asigació d'un valor a una variable
    |asig arrayInit                      {:RESULT =new SymbolVarInit();:}
    |                                    {:RESULT = new SymbolVarInit();:}
    //|asig subProgramCall                 {:RESULT =new SymbolVarInit();:}
    ;
//ARRAYS!
arrayInit ::=type lop integer lclose {:RESULT =new  SymbolArrayInit();:}
;//inicialització d'un array: 'nom' [arrayEllist]

type ::= r_int                 {:RESULT=new SymbolType();:}
    |r_bool                    {:RESULT=new SymbolType();:}
    |r_string                  {:RESULT=new SymbolType();:}
    ;


//FUNCIONS
funcDecl ::= r_function type id funcCap brop statementList return brcl {:RESULT=new SymbolFuncDecl();:}
    ; //declaració d'una funció
return   ::=r_return exprSimple smcol  {:RESULT = new SymbolReturn();:}
;
funcCap ::= ContCap rparen                  {:RESULT=new SymbolFuncCap();:}               //declaració de parentesis per als arguments
    | lparen rparen                         {:RESULT=new SymbolFuncCap();:}
    ;

procDecl ::= r_procedure id procCap brop statementList brcl{:RESULT =new SymbolProcDecl();:}; //declaració d'un procediment: proc 'nom' parametres {...}

procCap ::=ContCap rparen       {:RESULT = new SymbolProcCap();:} //declaració de parentesis per als arguments
    |lparen rparen                  {:RESULT = new SymbolProcCap();:}
    ;

ContCap ::= lparen argType type id      {:RESULT = new SymbolContCap();:}//tancam parentesis i definim els paràmetres
    | ContCap com argType type id   {:RESULT = new SymbolContCap();:}
    ;

argType ::= r_const {:RESULT = new SymbolArgType();:}   //tipus d'argument (constant o no)
    |               {:RESULT = new SymbolArgType();:}
    ;
//INSTRUCCIONS
statementList ::= statement statementList {:RESULT= new SymbolStatementList();:}      //declaració d'una llista
    |                                     {:RESULT=new SymbolStatementList();:}
    ;

statement ::= varDecl smcol         {:RESULT=new SymbolStatement();:}
    |exprSimple smcol               {:RESULT=new SymbolStatement();:}
    |forIteration                   {:RESULT=new SymbolStatement();:}
    |whileStatement                 {:RESULT=new SymbolStatement();:}
    |inputStatement smcol           {:RESULT=new SymbolStatement();:}
    |printStatement smcol           {:RESULT=new SymbolStatement();:}
    |ifStatement                    {:RESULT=new SymbolStatement();:}
    |SwitchCase                     {:RESULT=new SymbolStatement();:}
    |r_break smcol                  {:RESULT=new SymbolStatement();:}
    ;

inputStatement ::= r_input lparen rparen {:RESULT = new SymbolInputStatement();:};

printStatement ::= r_print lparen stringValue rparen {:RESULT = new SymbolPrintStatement();:};

stringValue    ::= literal
                   | stringValue add literal {:RESULT = new SymbolStringValue();:};

literal ::=          string {:RESULT = new SymbolLiteral();:}
                    | valor {:RESULT = new SymbolLiteral();:};


//EXPRESSIONS
exprSimple ::=lparen exprSimple rparen operacio{:RESULT=new SymbolExpressioSimple();:}
    |valor operacio                            {:RESULT=new SymbolExpressioSimple();:}
    ;

valor::= id                         {:RESULT=new SymbolValor("soy un id en valor");:}
    |array                          {:RESULT=new SymbolValor("soy un array en valor");:}
    |integer                        {:RESULT=new SymbolValor("soy un integer en valor");:}
    |bool                           {:RESULT=new SymbolValor("soy un bool en valor");:}
    |r_not bool                     {:RESULT=new SymbolValor("soy un r_not bool en valor");:}
    |subProgramCall                 {:RESULT=new SymbolValor("soy un subProgramCall en valor");:}
    ;

array::=id lop exprSimple lclose {:RESULT=new SymbolArray();:}
;

operacio::=op exprSimple   {:RESULT = new SymbolOper();:}
            | varInit      {:RESULT = new SymbolOper();:}
            ;

//OPERADORS
op::= boolOp {:RESULT = new SymbolOperador();:}
|aritOp      {:RESULT = new SymbolOperador();:}
|realOp      {:RESULT = new SymbolOperador();:}
;

boolOp::= r_and {:RESULT = new SymbolBoolOp();:}
|r_or           {:RESULT = new SymbolBoolOp();:}
;

aritOp ::= add {:RESULT = new SymbolAritOp();:}
|sub           {:RESULT = new SymbolAritOp();:}
|mul           {:RESULT = new SymbolAritOp();:}
|div           {:RESULT = new SymbolAritOp();:}
|mod           {:RESULT = new SymbolAritOp();:}
;

realOp::= neg {:RESULT = new SymbolRealOp();:}
|eq           {:RESULT = new SymbolRealOp();:}
|bg           {:RESULT = new SymbolRealOp();:}
|sm           {:RESULT = new SymbolRealOp();:}
|bg_eq        {:RESULT = new SymbolRealOp();:}
|sm_eq        {:RESULT = new SymbolRealOp();:}
;


subProgramCall ::= id lparen rparen {:RESULT = new SymbolSubProgramCall();:}
|subProgramContCall rparen          {:RESULT = new SymbolSubProgramCall();:}
;

subProgramContCall ::= id lparen exprSimple {:RESULT = new SymbolSubProgramContCall();:}
    |subProgramContCall com exprSimple      {:RESULT = new SymbolSubProgramContCall();:}
    ;

SwitchCase ::= r_switch lparen exprSimple rparen brop LCases Default brcl {:RESULT = new SymbolSwitchCase();:};
LCases ::= Case LCases {:RESULT = new SymbolLCases();:}
    |                  {:RESULT = new SymbolLCases();:}
    ;
Case ::= r_case exprSimple twodots statementList {:RESULT = new SymbolCase();:};
Default ::= r_default twodots statementList      {:RESULT = new SymbolDefault();:}
    |                                            {:RESULT = new SymbolDefault();:}
    ;
forIteration ::= r_for lparen forInit smcol exprSimple smcol forPostExpression rparen brop statementList brcl {:RESULT = new SymbolForStatement();:}
    ;

forInit ::= varDecl {:RESULT = new SymbolForInit();:}//inicialització de l'iterador
    |               {:RESULT = new SymbolForInit();:};

forPostExpression ::= exprSimple  {:RESULT = new SymbolForPostExpression();:}//declaració de la postExpressio
    |                             {:RESULT = new SymbolForPostExpression();:}
    ;

whileStatement ::= r_while lparen exprSimple rparen brop statementList brcl {:RESULT = new SymbolWhileStatement();:};//while (expresio){...}

ifStatement ::= r_if lparen exprSimple rparen elseStatement brcl {:RESULT = new SymbolIfStatement();:};

elseStatement ::= elseIfStatement r_else brop statementList {:RESULT = new SymbolElseStatement();:}
    | brop statementList                                    {:RESULT = new SymbolElseStatement();:}
    ;


